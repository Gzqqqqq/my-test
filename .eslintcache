[{"/Users/beisen/Desktop/study/my-test/src/index.js":"1","/Users/beisen/Desktop/study/my-test/src/reportWebVitals.js":"2","/Users/beisen/Desktop/study/my-test/src/App.js":"3","/Users/beisen/Desktop/study/my-test/src/components/palindrome.js":"4","/Users/beisen/Desktop/study/my-test/src/components/romanToInt.js":"5","/Users/beisen/Desktop/study/my-test/src/components/longestCommonPrefix.js":"6","/Users/beisen/Desktop/study/my-test/src/components/isValid.js":"7","/Users/beisen/Desktop/study/my-test/src/components/List/creatListClass.js":"8","/Users/beisen/Desktop/study/my-test/src/components/List/index.js":"9","/Users/beisen/Desktop/study/my-test/src/components/List/list-test.js":"10"},{"size":500,"mtime":1611499545833,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1611499545834,"results":"13","hashOfConfig":"12"},{"size":1953,"mtime":1612110536705,"results":"14","hashOfConfig":"12"},{"size":1115,"mtime":1611499545833,"results":"15","hashOfConfig":"12"},{"size":768,"mtime":1611499545833,"results":"16","hashOfConfig":"12"},{"size":1216,"mtime":1611499545832,"results":"17","hashOfConfig":"12"},{"size":2483,"mtime":1611499545832,"results":"18","hashOfConfig":"12"},{"size":5001,"mtime":1612100253204,"results":"19","hashOfConfig":"12"},{"size":4298,"mtime":1611499545831,"results":"20","hashOfConfig":"21"},{"size":2494,"mtime":1612110351801,"results":"22","hashOfConfig":"12"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},"1oy02m3",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"25"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"25"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"25"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"jwkb48",{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/beisen/Desktop/study/my-test/src/index.js",[],["47","48"],"/Users/beisen/Desktop/study/my-test/src/reportWebVitals.js",[],"/Users/beisen/Desktop/study/my-test/src/App.js",["49","50","51","52"],"/Users/beisen/Desktop/study/my-test/src/components/palindrome.js",[],"/Users/beisen/Desktop/study/my-test/src/components/romanToInt.js",[],"/Users/beisen/Desktop/study/my-test/src/components/longestCommonPrefix.js",["53","54","55"],"/**\n * 解题思路：\n * 1、横向比较：取第第一和第二个字符串，找到二者最长公共前缀，再往后比较公共前缀是否符合需求\n * 2、纵向比较：每个字符串的首字母开始比较，相同就继续比较第二个，直到比较到不同返回字符串\n * 3、找出ASCII码最大和最小的两个字符串进行比较取最大相同前缀（先排序再比较大小，时间空间复杂度取决于排序）\n */\n/**\n * @param {string[]} strs\n * @return {string}\n */\nconst longestCommonPrefix = strs => {\n  // 方法一\n  // if (strs.length == 0) return \"\";\n  // let prex = strs[0];\n  // if (strs.length == 1) return strs[0];\n\n  // for (let i = 1; i < strs.length; i++) {\n  //   while (!strs[i].startsWith(prex)) {   // 判断strs前缀是否是prex\n  //     prex = prex.substring(0, prex.length - 1);\n  //   }\n  // }\n  // return prex;\n\n  // 方法二\n  if (strs.length == 0) return \"\";\n  for (let i = 0; i < strs[0].length; i++) {\n    let prex = strs[0][i];\n    for (let j = 1; j < strs.length; j++) {\n      if (i == strs[j].length || strs[j][i] != prex) {\n        return strs[0].substring(0, i);\n      }\n    }\n  }\n  return strs[0];\n};\n\nexport default longestCommonPrefix;\n","/Users/beisen/Desktop/study/my-test/src/components/isValid.js",["56","57"],"/*\n* 1、替换法；找到一个[]、{}、()就替换成空，最后如果结果是空则是正确匹配的 暴力解法\n* 2、利用栈先进后出进行匹配（中规中矩，写的略微有些麻烦）\n*/\n\nconst map = {\n  '(': ')',\n  '[': ']',\n  '{': '}'\n}\n\nconst Json = {\n  ')': '(',\n  '}': '{',\n  ']': '['\n}\n/**\n * @param {string} s\n * @return {boolean}\n */\nconst isValid = s => {\n  // 方法一：替换\n  // if (s.length % 2 !== 0) return false;  // 先判定字符串长度\n  // while (s.includes('{}') || s.includes('[]') || s.includes('()')) {\n  //   s = s.replace('{}', '');\n  //   s = s.replace('[]', '');\n  //   s = s.replace('()', '');\n  // }\n  // return s === '';\n\n  // 方法二：栈先进后出  写的太麻烦了\n  // if (s.length % 2 !== 0) return false;  // 先判定字符串长度\n  // let stack = [];\n  // for (let i in s) {\n  //   if (s[i] == '{' || s[i] == '(' || s[i] == '[') {\n  //     stack.push(s[i]);\n  //   } else if (s[i] == '}') {\n  //     if (stack.length === 0) {\n  //       return false;\n  //     }\n  //     if (stack[stack.length - 1] == '{') {\n  //       stack.pop();\n  //     } else {\n  //       return false\n  //     }\n  //   } else if (s[i] == ')') {\n  //     if (stack.length === 0) {\n  //       return false;\n  //     }\n  //     if (stack[stack.length - 1] == '(') {\n  //       stack.pop();\n  //     } else {\n  //       return false\n  //     }\n  //   } else if (s[i] == ']') {\n  //     if (stack.length === 0) {\n  //       return false;\n  //     }\n  //     if (stack[stack.length - 1] == '[') {\n  //       stack.pop();\n  //     } else {\n  //       return false\n  //     }\n  //   }\n  // }\n  // return stack.length === 0\n\n  // 方法二改进：\n  // if (s.length % 2 !== 0) return false;  // 先判定字符串长度\n  // let stack = [];\n  // for (let i in s) {\n  //   if (s[i] === '{' || s[i] === '(' || s[i] === '[') {\n  //     stack.push(s[i]);\n  //   } else if (stack.length === 0 || map[stack[stack.length - 1]] !== s[i]) {\n  //     return false\n  //   } else {\n  //     stack.pop();\n  //   }\n  // }\n  // return stack.length === 0\n\n  // 方法三：\n  if (s.length % 2 !== 0) return false;  // 先判定字符串长度\n  let stack = [];\n  for (let i in s) {\n    let temp = s[i];\n    if (temp in Json) {\n      let template = stack.length !== 0 ? stack.pop() : '#'\n      if (template != Json[temp]) {\n        return false;\n      }\n    } else {\n      stack.push(temp);\n    }\n  }\n  return stack.length === 0\n\n};\n\nexport default isValid;","/Users/beisen/Desktop/study/my-test/src/components/List/creatListClass.js",["58","59"],"\n//  辅助类，用来描述链表中的节点\nexport function ListNode (val, next) {\n  this.val = (val === undefined ? 0 : val)\n  this.next = (next === undefined ? null : next)\n}\n\n// 双链表节点\nexport function ListNode2 (val) {\n  this.val = (val === undefined ? 0 : val)\n  this.next = null\n  this.previous = null\n}\n\n// 链表类\nexport class LinkedList {\n  constructor(headNode, nodeLength) {\n    this.length = nodeLength || 0;\n    this.head = headNode || null;\n  }\n\n  // 添加节点single  append时间复杂度==getElementAt的复杂度 O(n)\n  append = (element) => {\n    let node = new ListNode(element);\n    // 当前列表为空，直接添加到head后面\n    if (this.head === null) {\n      this.head = node;\n    } else {  // 找到链表结尾,添加新元素\n      let lastNode = this.getElementAt(this.length - 1);\n      lastNode.next = node;\n    }\n    this.length++;\n    return true;\n  }\n\n  // 添加节点double\n  appendDouble = (element) => {\n    let node = new ListNode2(element);\n    // 当前列表为空，直接添加到head后面\n    if (this.head === null) {\n      this.head = node;\n    } else {  // 找到链表结尾,添加新元素\n      let lastNode = this.getElementAt(this.length - 1);\n      lastNode.next = node;\n      node.previous = lastNode;\n    }\n    this.length++;\n    return true;\n  }\n\n  // 批量添加数组：   O(n*m)\n  appendArr = (eleArr) => {\n    eleArr.forEach(item => {\n      this.append(item);\n    });\n  }\n\n  // 指定位置插入single   O(n)\n  insert = (element, position) => {\n    if (position < 0 || position > this.length) {\n      return null;\n    }\n    let node = new ListNode(element);\n    // 插入head头部\n    if (position === 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {  // 找到要插入位置的pre，进行替换\n      let prevNode = this.getElementAt(position - 1);\n      node.next = prevNode.next;\n      prevNode.next = node;\n    }\n    this.length++;\n    return true;\n  }\n\n  // 指定位置插入double\n  insertDouble = (element, position) => {\n    if (position < 0 || position > this.length) {\n      return null;\n    }\n    let node = new ListNode2(element);\n    // 插入head头部\n    if (position === 0) {\n      node.next = this.head;\n      this.head = node;\n    } else {  // 找到要插入位置的pre，进行替换\n      let currentNode = this.getElementAt(position);\n      node.previous = currentNode.previous;\n      currentNode.previous.next = node;\n\n      node.next = currentNode\n      currentNode.previous = node;\n    }\n    this.length++;\n    return true;\n  }\n\n  // 指定位置删除single   O(n)\n  removeAt = (position) => {\n    if (position < 0 || position > this.length) {\n      return null;\n    }\n    // 标记当前要删除的元素\n    let current = this.head;\n\n    if (position == 0) { // 删除head\n      this.head = current.next;\n    } else {\n      let prevNode = this.getElementAt(position - 1);\n      current = prevNode.next;\n      prevNode.next = current.next;\n    }\n    this.length--;\n    return current;\n  }\n\n  // 指定位置删除double\n  removeAtDouble = (position) => {\n    if (position < 0 || position > this.length) {\n      return null;\n    }\n    // 标记当前要删除的元素\n    let current = this.head;\n\n    if (position == 0) { // 删除head\n      this.head = current.next;\n    } else {\n      let curNode = this.getElementAt(position);\n      curNode.previous.next = curNode.next;\n      curNode.next.previous = curNode.previous;\n    }\n    this.length--;\n    return current;\n  }\n\n  // 删除指定元素   O(n)\n  removeEle = (element) => {\n    let position = this.indexOf(element);\n    return this.removeAt(position);\n  }\n\n  // 返回指定元素下标  O(n)\n  indexOf = (element) => {\n    let current = this.head;\n\n    for (let i = 0; i < this.length; i++) {\n      if (current.val === element) {\n        return i;\n      }\n      current = current.next;\n    }\n\n    return -1\n  }\n\n  // 返回指定下标元素  getElementAt的时间复杂度为O(n)\n  getElementAt = (position) => {\n    if (position < 0 || position > this.length) {  // 超出下标\n      return null;\n    }\n\n    let current = this.head;\n    for (let i = 0; i < position; i++) {\n      current = current.next\n    }\n\n    return current;\n  }\n\n  // 判断链表是否为空  O(1)\n  isEmpty = () => {\n    return this.length === 0;\n  }\n\n  // 返回链表个数  O(1)\n  size = () => {\n    return this.length;\n  }\n\n  // 返回链接头部   O(1)\n  getHead = () => {\n    return this.head;\n  }\n\n  // 清空链表  O(1)\n  clear = () => {\n    this.head = null;\n    this.length = 0;\n  }\n\n  // 指定格式输出链表元素  O(n)\n  toString = () => {\n    let current = this.head;\n    let s = '';\n    while (current.next) {\n      s += current.val + '->'\n      current = current.next\n    }\n    s += current.val;\n    return s;\n  }\n\n  // 更新指定位置元素  O(n)\n  updateList = (position, element) => {\n    // 指定位置删除，再新增\n    this.removeAt(position);\n    this.insert(element, position);\n  }\n}\n","/Users/beisen/Desktop/study/my-test/src/components/List/index.js",["60","61"],"/Users/beisen/Desktop/study/my-test/src/components/List/list-test.js",["62"],{"ruleId":"63","replacedBy":"64"},{"ruleId":"65","replacedBy":"66"},{"ruleId":"67","severity":1,"message":"68","line":3,"column":8,"nodeType":"69","messageId":"70","endLine":3,"endColumn":20},{"ruleId":"67","severity":1,"message":"71","line":5,"column":8,"nodeType":"69","messageId":"70","endLine":5,"endColumn":18},{"ruleId":"67","severity":1,"message":"72","line":7,"column":8,"nodeType":"69","messageId":"70","endLine":7,"endColumn":27},{"ruleId":"67","severity":1,"message":"73","line":9,"column":8,"nodeType":"69","messageId":"70","endLine":9,"endColumn":15},{"ruleId":"74","severity":1,"message":"75","line":25,"column":19,"nodeType":"76","messageId":"77","endLine":25,"endColumn":21},{"ruleId":"74","severity":1,"message":"75","line":29,"column":13,"nodeType":"76","messageId":"77","endLine":29,"endColumn":15},{"ruleId":"74","severity":1,"message":"78","line":29,"column":45,"nodeType":"76","messageId":"77","endLine":29,"endColumn":47},{"ruleId":"67","severity":1,"message":"79","line":6,"column":7,"nodeType":"69","messageId":"70","endLine":6,"endColumn":10},{"ruleId":"74","severity":1,"message":"78","line":89,"column":20,"nodeType":"76","messageId":"77","endLine":89,"endColumn":22},{"ruleId":"74","severity":1,"message":"75","line":107,"column":18,"nodeType":"76","messageId":"77","endLine":107,"endColumn":20},{"ruleId":"74","severity":1,"message":"75","line":126,"column":18,"nodeType":"76","messageId":"77","endLine":126,"endColumn":20},{"ruleId":"67","severity":1,"message":"80","line":2,"column":10,"nodeType":"69","messageId":"70","endLine":2,"endColumn":18},{"ruleId":"74","severity":1,"message":"75","line":74,"column":15,"nodeType":"76","messageId":"77","endLine":74,"endColumn":17},{"ruleId":"67","severity":1,"message":"81","line":1,"column":20,"nodeType":"69","messageId":"70","endLine":1,"endColumn":30},"no-native-reassign",["82"],"no-negated-in-lhs",["83"],"no-unused-vars","'isPalindrome' is defined but never used.","Identifier","unusedVar","'RomanToInt' is defined but never used.","'LongestCommonPrefix' is defined but never used.","'isValid' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'map' is assigned a value but never used.","'ListNode' is defined but never used.","'LinkedList' is defined but never used.","no-global-assign","no-unsafe-negation"]